/**
 * @description Module that gets and adds the price
 * for each trip (i.e. row of a csv file generated by
 * STS luxury).
 *
 * @author Bryan Guillen
 */

 /**********************
  * TODOs
  * - For 'addPriceToTripMap'
  *   - Ensure that the args are 'price, trip'
  * - Ensure that each function on page is doing
  *   one thing, and one thing only
  * - Write tests for functions
  * - Remove '""' from updated CSV
  * - Wrap this logic into an express app
  *   - When deploying ensure googleApiKey is private
  * - Create a frontend to interact with this
  *   express app
  ***********************/

/**********************
 * Variables
 ***********************/

const csvToJSON = require('csvtojson');
const config = require('./config');
const googleMapsClient = require('@google/maps').createClient({
  key: config.googleApiKey, // THIS SHOULD BE HIDDEN PROD!!
  Promise: Promise
});
const Json2CsvParser = require('json2csv').Parser;
const fs = require('fs');
const convert = require('convert-units');

const csvFile = './stsTripData.csv';

/**********************
 * Functions
 ***********************/

function addPricesToCsv(csvFile) {
 parseTripsCsv(csvFile)
   .then((trips) => {
     const addPricesToTripsAsynchronously = [];

     for (let trip of trips) {
       let origin = getPickupLatLng(trip);
       let destination = getDropoffLatLng(trip);
       let addPriceToTripMapPromise = addPriceToTripMap(trip, origin, destination);
       addPricesToTripsAsynchronously.push(addPriceToTripMapPromise);
     }

     return addPricesToTripsAsynchronously;
   })
   .then((addPricesToTripsAsynchronously) => {
     writeUpdatedTripData(addPricesToTripsAsynchronously);
   })
   .catch((error) => {
     console.log(error);
   });
}

function addPriceToTripMap(trip, origin, destination) {
  return new Promise((resolve, reject) => {
    getTripMileage(origin, destination)
      .then((distance) => {
        const price = getPrice(parseFloat(distance));
        trip.price = price;
        resolve(trip);
      })
      .catch((error) => {
        reject(error);
      });
  });
}

function getDropoffLatLng(trip) {
 const DROPOFF_LATITUDE = 'dropoff_latitude';
 const DROPOFF_LONGITUDE = 'dropoff_longitude';
 const dropoffLatLngObject = trip[DROPOFF_LATITUDE] + ',' + trip[DROPOFF_LONGITUDE];

 return dropoffLatLngObject;
}

function getPickupLatLng(trip) {
 const PICKUP_LATITUDE = 'pickup_latitude';
 const PICKUP_LONGITUDE = 'pickup_longitude';
 const pickupLatLngObject = trip[PICKUP_LATITUDE] + ',' + trip[PICKUP_LONGITUDE];

 return pickupLatLngObject;
}

function getPrice(miles) {
  let price = '';

  if (miles < 6) {
    price = '15$';
  } else if (miles < 9) {
    price = '17$';
  } else {
    // this should be added to another function
    // so that the logic can be unit tested
    price = 17 + ((210 * (miles - 9)) / 100) + '$';
  }

  return price;
}

function getTripMileage(origin, destination) {
  return new Promise ((resolve, reject) => {
    googleMapsClient.directions({
      origin,
      destination
    }).asPromise()
      .then((response) => {
        distance = response.json.routes[0].legs[0].distance.text;
        resolve(distance);
      })
      .catch((error) => {
        reject(error);
      });
  });
}

function parseTripsCsv(csvFile) {
  return new Promise((resolve, reject) => {
    csvToJSON()
      .fromFile(csvFile)
      .then((result) => {
        resolve(result);
      })
      .catch((error) => {
        reject(error);
      });
  });
}

function writeUpdatedTripData(updatedTripsData) {
  Promise.all(updatedTripsData)
        .then((values) => {
          const json2csvParser = new Json2CsvParser({ values, doubleQuote: '' });
          const csv = json2csvParser.parse(values);

          fs.writeFile('./updatedCsvFile.csv', csv, (error) => {
            if (error) {
              throw error;
            }
            console.log('Successully written to file'); // Remove this once testing is done
          });
        })
        .catch((error) => {
          console.log(error);
        })
}

addPricesToCsv(csvFile);
